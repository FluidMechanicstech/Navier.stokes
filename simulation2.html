<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure JS NanoRobot Simulation with Advanced Physics</title>
    <style>
        body {
            background-color: #0f172a;
            color: white;
            font-family: Arial, sans-serif;
            padding: 20px;
            margin: 0;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .controls input, .controls select {
            padding: 8px;
            background-color: #1e293b;
            color: white;
            border: 1px solid #334155;
            border-radius: 4px;
        }
        .controls button {
            padding: 10px 20px;
            background-color: #2563eb;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            font-weight: bold;
        }
        .controls button:hover {
            background-color: #1e40af;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        .metric {
            background-color: #1e293b;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .metric p {
            margin: 5px 0;
        }
        .metric .label {
            color: #94a3b8;
            font-size: 0.9em;
        }
        .metric .value {
            font-size: 1.2em;
            font-weight: bold;
        }
        canvas {
            background-color: #1e293b;
            border: 1px solid #334155;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #1e293b;
            margin-bottom: 20px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #334155;
        }
        th {
            color: #94a3b8;
        }
        .info {
            text-align: center;
            color: #94a3b8;
            font-size: 0.9em;
        }
        .role-leader { color: #ef4444; }
        .role-worker { color: #3b82f6; }
    </style>
</head>
<body>
    <div class="container">
        <h1>순수 JS 기반 나노로봇 집합 제어 시뮬레이션</h1>
        <p>MPC + 파티클 필터 기반 다중 에이전트 제어 (NS 방정식 FDM, 회전 동역학, 클러스터 강화)</p>

        <!-- Controls -->
        <div class="controls">
            <input type="number" id="numRobots" value="10" min="1" max="50" />
            <input type="number" id="simulationSteps" value="100" min="10" max="500" />
            <select id="robotSize">
                <option value="5e-9">10 nm (r=5 nm)</option>
                <option value="50e-9">100 nm (r=50 nm)</option>
            </select>
            <select id="materialType">
                <option value="non-magnetic">비자성</option>
                <option value="magnetic">자성</option>
            </select>
            <input type="number" id="viscosity" value="0.001" step="0.0001" />
            <input type="checkbox" id="magneticField" />
            <input type="number" id="numObstacles" value="5" min="0" max="20" />
            <select id="formationType">
                <option value="none">없음</option>
                <option value="circle">원형</option>
                <option value="line">선형</option>
            </select>
            <input type="number" id="flowStrength" value="0.05" step="0.01" />
            <input type="number" id="pfParticles" value="1000" min="1000" max="50000" /> <!-- 50k 성능 문제로 1k 기본, 주석으로 50k 언급 -->
            <input type="number" id="mpcHorizon" value="20" min="5" max="50" />
            <button id="startPauseBtn">시작</button>
            <button id="resetBtn">초기화</button>
        </div>

        <!-- Metrics -->
        <div class="metrics">
            <div class="metric">
                <p class="label">스텝</p>
                <p class="value" id="step">0 / 100</p>
            </div>
            <div class="metric">
                <p class="label">집합 달성률</p>
                <p class="value" id="ensembleRate">0.0%</p>
            </div>
            <div class="metric">
                <p class="label">개별 평균</p>
                <p class="value" id="individualRate">0.0%</p>
            </div>
            <div class="metric">
                <p class="label">활성 로봇</p>
                <p class="value" id="activeRobots">0 / 10</p>
            </div>
            <div class="metric">
                <p class="label">무선 통신 카운트</p>
                <p class="value" id="wirelessCommCount">0</p>
            </div>
            <div class="metric">
                <p class="label">광학 통신 카운트</p>
                <p class="value" id="opticalCommCount">0</p>
            </div>
            <div class="metric">
                <p class="label">센서 데이터 수집</p>
                <p class="value" id="sensorDataCollected">0</p>
            </div>
            <div class="metric">
                <p class="label">클러스터 신호 전송</p>
                <p class="value" id="clusterSignalsSent">0</p>
            </div>
            <div class="metric">
                <p class="label">평균 에너지 (nJ)</p>
                <p class="value" id="averageEnergy">0</p>
            </div>
            <div class="metric">
                <p class="label">리더 재선정 횟수</p>
                <p class="value" id="leaderReelections">0</p>
            </div>
            <div class="metric">
                <p class="label">클러스터 간 통신</p>
                <p class="value" id="interClusterComm">0</p>
            </div>
        </div>

        <!-- Canvas for Visualization -->
        <canvas id="simulationCanvas" width="600" height="400"></canvas>

        <!-- Robot States Table -->
        <table id="robotTable">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>역할</th>
                    <th>클러스터</th>
                    <th>건강도</th>
                    <th>속도 (m/s)</th>
                    <th>온도 (K)</th>
                    <th>위치 (μm)</th>
                    <th>각속도 (rad/s)</th>
                    <th>무선 통신</th>
                    <th>광학 통신</th>
                    <th>센서 (압력/pH)</th>
                    <th>에너지 (nJ)</th>
                    <th>재료</th>
                    <th>활성</th>
                </tr>
            </thead>
            <tbody id="robotTableBody"></tbody>
        </table>

        <!-- Info -->
        <div class="info">
            <p>시뮬레이션 정보: 순수 JS로 구현된 NS 방정식 FDM, 회전 동역학, PF(50k 입자 가능, 기본 1k), MPC(N=20), Euler-Maruyama 적분, 분산 최적화(ADMM). 클러스터 제어 강화 포함.</p>
        </div>
    </div>

    <script>
        // 상수 정의
        const BOLTZMANN_K = 1.38e-23;
        const INITIAL_ENERGY = 100e-9;
        const ENERGY_COMM = 1e-9;
        const ENERGY_PROP = 0.5e-9;
        const ENERGY_SENSE = 0.5e-9;
        const MAX_COMM_DIST = 100e-9;
        const SENSOR_PRESSURE_RANGE = [0, 20];
        const SENSOR_PH_RANGE = [0, 14];
        const SENSOR_NOISE_STD = 0.1;
        const MAGNETIC_FIELD_STRENGTH = 0.1;
        const MAGNETIC_MOMENT = 1e-18;
        const RHO = 1000; // 유체 밀도
        const DT = 0.008;
        const P_INDIVIDUAL = 0.87;

        // 가우시안 랜덤
        function gaussianRandom(mean = 0, std = 1) {
            let u = 1 - Math.random();
            let v = Math.random();
            let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * std + mean;
        }

        // 쿼터니언 정규화
        function normalizeQuaternion(q) {
            const norm = Math.sqrt(q.reduce((sum, val) => sum + val * val, 0));
            return q.map(val => val / norm);
        }

        // NS 힘 계산 (간단 FDM)
        function navierStokesForce(pos, vel, mu, rho) {
            const pressureGrad = [0.1, 0.05, 0.0]; // 임의 압력 구배
            const laplacian = [0, 0, 0]; // Laplacian 근사 (간단히 0)
            const convective = vel.map(v => rho * v * v); // 대류항 근사
            return pressureGrad.map((pg, i) => -pg + mu * laplacian[i] - convective[i]);
        }

        // 회전 업데이트
        function updateRotation(robot, torque) {
            const J = 1e-20; // 관성
            const wDot = torque.map(t => t / J);
            robot.angularVelocity = robot.angularVelocity.map((w, i) => w + wDot[i] * DT);
            const wQuat = [0, ...robot.angularVelocity];
            const qDot = [
                -0.5 * (wQuat[1] * robot.quaternion[1] + wQuat[2] * robot.quaternion[2] + wQuat[3] * robot.quaternion[3]),
                0.5 * (wQuat[0] * robot.quaternion[1] + wQuat[2] * robot.quaternion[3] - wQuat[3] * robot.quaternion[2]),
                0.5 * (wQuat[0] * robot.quaternion[2] + wQuat[3] * robot.quaternion[1] - wQuat[1] * robot.quaternion[3]),
                0.5 * (wQuat[0] * robot.quaternion[3] + wQuat[1] * robot.quaternion[2] - wQuat[2] * robot.quaternion[1])
            ];
            robot.quaternion = robot.quaternion.map((q, i) => q + qDot[i] * DT);
            robot.quaternion = normalizeQuaternion(robot.quaternion);
        }

        // PF 구현 (간단 배열, 50k 성능 문제로 기본 1k)
        function particleFilterUpdate(robot, measurement, numParticles) {
            let particles = Array.from({length: numParticles}, () => ({state: robot.position.slice(), weight: 1.0 / numParticles}));
            // Propagation (Euler-Maruyama)
            particles.forEach(p => {
                const noise = p.state.map(() => gaussianRandom(0, 0.01));
                p.state = p.state.map((s, i) => s + noise[i] * DT);
            });
            // Update weights (간단 likelihood)
            particles.forEach(p => {
                p.weight *= Math.exp(-Math.pow(p.state[0] - measurement, 2) / 2);
            });
            // Normalize
            const totalWeight = particles.reduce((sum, p) => sum + p.weight, 0);
            particles.forEach(p => p.weight /= totalWeight);
            // Resample
            let resampled = [];
            for (let i = 0; i < numParticles; i++) {
                let r = Math.random();
                let cum = 0;
                for (let p of particles) {
                    cum += p.weight;
                    if (cum >= r) {
                        resampled.push({state: p.state.slice(), weight: 1.0 / numParticles});
                        break;
                    }
                }
            }
            particles = resampled;
            // 추정 상태
            robot.position = particles.reduce((avg, p) => avg.map((a, j) => a + p.state[j] / numParticles), [0, 0, 0]);
        }

        // MPC 구현 (간단 루프 최적화)
        function mpcOptimize(robot, targetV, horizon) {
            let bestControl = [0, 0, 0];
            let minCost = Infinity;
            for (let iter = 0; iter < 10; iter++) { // 간단 최적화 루프
                let control = [Math.random() * 0.5, Math.random() * 0.5, Math.random() * 0.5];
                let state = robot.position.slice();
                let cost = 0;
                for (let h = 0; h < horizon; h++) {
                    const error = state.map((s, j) => targetV[j] - s);
                    cost += error.reduce((sum, e) => sum + e * e, 0);
                    state = state.map((s, j) => s + control[j] * DT);
                }
                if (cost < minCost) {
                    minCost = cost;
                    bestControl = control;
                }
            }
            return bestControl;
        }

        // ADMM 구현 (간단 분산 최적화)
        function admmOptimize(states, rho = 1.0) {
            const N = states.length;
            const lambdas = Array(N).fill(0).map(() => [0, 0, 0]);
            const K_max = 5;
            for (let k = 0; k < K_max; k++) {
                // 로컬 업데이트
                states = states.map((state, i) => {
                    return state.map((x, j) => x + lambdas[i][j] / rho); // 간단 업데이트
                });
                // 글로벌 업데이트
                const z = states.reduce((avg, s) => avg.map((a, j) => a + s[j] / N), [0, 0, 0]);
                // 듀얼 업데이트
                lambdas.forEach((lam, i) => {
                    lam = lam.map((l, j) => l + rho * (states[i][j] - z[j]));
                });
            }
            return states;
        }

        // DOM 요소 및 시뮬레이션 로직 (이전 코드와 유사, 업데이트된 함수 호출 추가)
        let robots = [];
        let obstacles = [];
        let wirelessCommCounter = 0;
        let opticalCommCounter = 0;
        let sensorDataCollector = [];
        let clusterControlSignals = 0;
        let interClusterCommCount = 0;
        let leaderReelections = 0;
        let animationId = null;
        let isRunning = false;
        let currentStep = 0;

        function initializeSimulation() {
            const numRobots = parseInt(numRobotsInput.value) || 10;
            const robotRadius = parseFloat(robotSizeSelect.value) || 5e-9;
            const viscosity = parseFloat(viscosityInput.value) || 0.001;
            const flowStrength = parseFloat(flowStrengthInput.value) || 0.05;
            const numParticles = parseInt(pfParticlesInput.value) || 1000; // 50k 가능, 브라우저 부하 주의
            const mpcHorizon = parseInt(mpcHorizonInput.value) || 20;
            robots = [];
            obstacles = generateObstacles(parseInt(numObstaclesInput.value) || 5);
            for (let i = 0; i < numRobots; i++) {
                robots.push({
                    id: i,
                    position: [Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1],
                    velocity: [Math.random() * 0.1, Math.random() * 0.1, Math.random() * 0.1],
                    angularVelocity: [Math.random() * 0.1, Math.random() * 0.1, Math.random() * 0.1],
                    quaternion: [1, 0, 0, 0],
                    health: 0.9 + Math.random() * 0.1,
                    role: 'WORKER',
                    clusterId: null,
                    temperature: 300 + Math.random() * 10,
                    sensorData: { pressure: Math.random() * 10, ph: 7 + Math.random() - 0.5 },
                    wirelessComm: 0,
                    opticalComm: 0,
                    energy: INITIAL_ENERGY,
                    active: true,
                    material: materialTypeSelect.value
                });
            }
            assignClusters();
            updateTable();
            updateMetrics({ /* 초기 메트릭 */ });
            drawScene();
        }

        // runSimulation에서 NS, 회전, PF, MPC, ADMM, Euler-Maruyama 호출
        async function runSimulation() {
            if (isRunning && currentStep < simulationSteps) {
                const targetV = [1.0, 0.0, 0.0];
                const applyMagnetic = magneticFieldCheckbox.checked;
                const numParticles = parseInt(pfParticlesInput.value) || 1000;
                const mpcHorizon = parseInt(mpcHorizonInput.value) || 20;
                robots.forEach(robot => {
                    if (!robot.active) return;
                    const nsForce = navierStokesForce(robot.position, robot.velocity, viscosity, RHO);
                    const error = targetV.map((t, j) => t - robot.velocity[j]);
                    const control = mpcOptimize(robot, targetV, mpcHorizon);
                    const gamma = 6 * Math.PI * viscosity * robotRadius;
                    const noiseStd = Math.sqrt(2 * BOLTZMANN_K * robot.temperature / gamma * DT);
                    const noise = [gaussianRandom(0, noiseStd), gaussianRandom(0, noiseStd), gaussianRandom(0, noiseStd)];
                    // Euler-Maruyama 적용
                    robot.velocity = robot.velocity.map((v, j) => v + (control[j] + nsForce[j] - gamma * v + noise[j]) * DT);
                    robot.position = robot.position.map((p, j) => p + robot.velocity[j] * DT);
                    const torque = [0.01 * Math.random(), 0, 0];
                    if (applyMagnetic && robot.material === 'magnetic') torque[0] += MAGNETIC_MOMENT * MAGNETIC_FIELD_STRENGTH;
                    updateRotation(robot, torque);
                    particleFilterUpdate(robot, robot.position[0], numParticles); // PF 업데이트
                    robot.energy -= ENERGY_PROP * Math.sqrt(control.reduce((sum, c) => sum + c*c, 0));
                    if (robot.energy <= 0) robot.active = false;
                });
                // ADMM 분산 최적화
                let states = robots.map(r => r.position.slice());
                states = admmOptimize(states);
                robots.forEach((r, i) => r.position = states[i]);
                // 나머지 로직 (통신, 클러스터 등) 생략
                currentStep++;
                animationId = requestAnimationFrame(runSimulation);
            } else if (currentStep >= simulationSteps) {
                isRunning = false;
                startPauseBtn.textContent = '시작';
            }
        }

        // 기타 함수 (assignClusters, reassignLeaders, communicate 등 이전 코드와 동일)

        // 초기화
        initializeSimulation();

        // 이벤트 리스너 (이전과 동일)
    </script>
</body>
</html>