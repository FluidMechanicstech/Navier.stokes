<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쌍곡선 함수의 비례식 변환 시각화</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        canvas {
            border: 2px solid #ccc;
            border-radius: 5px;
            display: block;
            margin: 10px 0;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .graph-container {
            margin-bottom: 20px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 15px;
        }
        
        h1, h2 {
            color: #333;
        }
        
        .info-box {
            background-color: #f0f7ff;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .info-box.yellow {
            background-color: #fffae6;
        }
        
        .info-box.purple {
            background-color: #f7f0ff;
        }
        
        .info-box.green {
            background-color: #f0fff5;
        }
        
        .hint {
            background-color: #e6f7ff;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin-top: 20px;
        }
        
        .label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .drag-hint {
            position: absolute; 
            top: 10px; 
            right: 10px; 
            background-color: rgba(220, 230, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">쌍곡선 함수의 비례식 변환 시각화</h1>
    <p style="text-align: center; color: #0066cc; font-weight: bold;">각 그래프를 드래그하여 매개변수를 조정할 수 있습니다!</p>
    
    <div class="graph-container">
        <h2>1. 기본 쌍곡선 함수: f(x) = a/(x-h) + k</h2>
        <div class="controls">
            <div class="control-group">
                <label class="label">a 값: <span id="a-value">2.0</span></label>
                <input type="range" id="a-slider" min="0.5" max="5" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label class="label">h 값: <span id="h-value">3.0</span></label>
                <input type="range" id="h-slider" min="-5" max="5" step="0.1" value="3.0">
            </div>
            <div class="control-group">
                <label class="label">k 값: <span id="k-value">1.0</span></label>
                <input type="range" id="k-slider" min="-5" max="5" step="0.1" value="1.0">
            </div>
        </div>
        <div style="position: relative;">
            <canvas id="canvas1" width="700" height="400"></canvas>
            <div class="drag-hint">드래그하여 매개변수 조정</div>
        </div>
        <div class="info-box">
            <p>
                <strong>특성:</strong> 수직 점근선 x = <span id="h-display">3.0</span>, 수평 점근선 y = <span id="k-display">1.0</span><br>
                <strong>음의 극한:</strong> x → -∞일 때, f(x) → <span id="k-limit-neg">1.0</span><br>
                <strong>양의 극한:</strong> x → +∞일 때, f(x) → <span id="k-limit-pos">1.0</span>
            </p>
        </div>
    </div>
    
    <div class="graph-container">
        <h2>2. 관성항을 도입한 비례식 변환: (y-k)(x-h) = a</h2>
        <div style="position: relative;">
            <canvas id="canvas2" width="700" height="400"></canvas>
            <div class="drag-hint">드래그하여 h와 k 조정</div>
        </div>
        <div class="info-box purple">
            <p>
                <strong>관성항 도입:</strong> y - <span id="k-display2">1.0</span> = <span id="a-display2">2.0</span>/(x-<span id="h-display2">3.0</span>)<br>
                <strong>비례식 변환:</strong> (y-<span id="k-display3">1.0</span>)(x-<span id="h-display3">3.0</span>) = <span id="a-display3">2.0</span><br>
                <strong>관계 해석:</strong> (y-<span id="k-display4">1.0</span>)와 (x-<span id="h-display4">3.0</span>)의 곱이 항상 <span id="a-display4">2.0</span>로 일정
            </p>
        </div>
    </div>
    
    <div class="graph-container">
        <h2>3. 평균변화율과 미분을 통한 비례식</h2>
        <div class="controls">
            <div class="control-group">
                <label class="label">x₁ 값: <span id="x1-value">4.0</span></label>
                <input type="range" id="x1-slider" min="3.5" max="8" step="0.1" value="4.0">
            </div>
            <div class="control-group">
                <label class="label">x₂ 값: <span id="x2-value">6.0</span></label>
                <input type="range" id="x2-slider" min="4.5" max="10" step="0.1" value="6.0">
            </div>
        </div>
        <div style="position: relative;">
            <canvas id="canvas3" width="700" height="400"></canvas>
            <div class="drag-hint">드래그하여 x₁와 x₂ 조정</div>
        </div>
        <div class="info-box green">
            <p>
                <strong>두 점:</strong> (<span id="x1-display">4.0</span>, <span id="y1-display">2.0</span>) 및 (<span id="x2-display">6.0</span>, <span id="y2-display">1.67</span>)<br>
                <strong>평균변화율:</strong> <span id="avg-rate">-0.1667</span><br>
                <strong>평균변화율의 x₂에 대한 미분:</strong> <span id="derivative">-0.0667</span><br>
                <strong>비례식 결과:</strong> ∂R/∂x₂ · (x₁-h) · (x₂-h)² = <span id="proportional-result">2.0000</span> ≈ <span id="a-display5">2.0</span>
            </p>
        </div>
    </div>
    
    <div class="info-box yellow">
        <h2 style="margin-top: 0;">결론: 비례식 변환 가능성</h2>
        <p>
            위 예시를 통해 살펴본 것처럼, 모든 쌍곡선 함수는 적절한 관성항 도입과 
            수학적 변환(평균변화율의 미분, 로그, 지수 변환 등)을 통해 비례식 형태로 
            표현할 수 있습니다. 특히 (y-k)(x-h) = a 형태나 
            ∂R/∂x₂ · (x₁-h) · (x₂-h)² = a 형태의 비례식으로 변환이 가능합니다.
        </p>
    </div>
    
    <div class="hint">
        <p style="font-weight: bold;">모든 그래프를 드래그하여 대화형으로 탐색할 수 있습니다!</p>
        <p style="font-size: 14px; margin-top: 5px;">첫 번째 그래프: a, h, k 값 변경</p>
        <p style="font-size: 14px;">두 번째 그래프: h와 k 값 변경</p>
        <p style="font-size: 14px;">세 번째 그래프: x₁과 x₂ 값 변경</p>
    </div>

    <script>
        // DOM이 완전히 로드된 후에 실행
        document.addEventListener('DOMContentLoaded', function() {
            // 파라미터 값 설정
            let a = 2.0;
            let h = 3.0;
            let k = 1.0;
            let x1 = 4.0;
            let x2 = 6.0;
            
            // 캔버스 참조
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const canvas3 = document.getElementById('canvas3');
            
            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            const ctx3 = canvas3.getContext('2d');
            
            // 슬라이더 참조
            const aSlider = document.getElementById('a-slider');
            const hSlider = document.getElementById('h-slider');
            const kSlider = document.getElementById('k-slider');
            const x1Slider = document.getElementById('x1-slider');
            const x2Slider = document.getElementById('x2-slider');
            
            // 값 표시 참조
            const aValue = document.getElementById('a-value');
            const hValue = document.getElementById('h-value');
            const kValue = document.getElementById('k-value');
            const x1Value = document.getElementById('x1-value');
            const x2Value = document.getElementById('x2-value');
            
            // 드래그 상태 추적
            let isDragging = false;
            let activeCanvas = null;
            
            // 그래프 설정
            const graphSettings = {
                xMin: -10,
                xMax: 10,
                yMin: -10,
                yMax: 10,
                xAxisStep: 1,
                yAxisStep: 1,
                gridStep: 1,
                margin: 40, // 그래프 주변 여백
                asymptoteColor: 'rgba(255, 0, 0, 0.5)',
                mainCurveColor: '#1e40af',
                transformedCurveColor: '#7e22ce',
                pointSize: 6
            };
            
            // 좌표 변환 함수
            function worldToScreen(canvas, worldX, worldY) {
                const width = canvas.width - 2 * graphSettings.margin;
                const height = canvas.height - 2 * graphSettings.margin;
                
                const screenX = graphSettings.margin + width * (worldX - graphSettings.xMin) / (graphSettings.xMax - graphSettings.xMin);
                const screenY = canvas.height - graphSettings.margin - height * (worldY - graphSettings.yMin) / (graphSettings.yMax - graphSettings.yMin);
                
                return { x: screenX, y: screenY };
            }
            
            function screenToWorld(canvas, screenX, screenY) {
                const width = canvas.width - 2 * graphSettings.margin;
                const height = canvas.height - 2 * graphSettings.margin;
                
                const worldX = graphSettings.xMin + (screenX - graphSettings.margin) * (graphSettings.xMax - graphSettings.xMin) / width;
                const worldY = graphSettings.yMin + (canvas.height - screenY - graphSettings.margin) * (graphSettings.yMax - graphSettings.yMin) / height;
                
                return { x: worldX, y: worldY };
            }
            
            // 쌍곡선 함수
            function hyperbolic(x) {
                if (Math.abs(x - h) < 0.001) return NaN; // 점근선에 너무 가까우면 스킵
                return a / (x - h) + k;
            }
            
            // 축 그리기
            function drawAxes(ctx, canvas) {
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 1;
                
                // 그리드 그리기
                ctx.beginPath();
                for (let x = Math.ceil(graphSettings.xMin); x <= Math.floor(graphSettings.xMax); x += graphSettings.gridStep) {
                    if (x === 0) continue; // 축과 겹치지 않게
                    const pos = worldToScreen(canvas, x, 0);
                    ctx.moveTo(pos.x, graphSettings.margin);
                    ctx.lineTo(pos.x, height - graphSettings.margin);
                }
                for (let y = Math.ceil(graphSettings.yMin); y <= Math.floor(graphSettings.yMax); y += graphSettings.gridStep) {
                    if (y === 0) continue; // 축과 겹치지 않게
                    const pos = worldToScreen(canvas, 0, y);
                    ctx.moveTo(graphSettings.margin, pos.y);
                    ctx.lineTo(width - graphSettings.margin, pos.y);
                }
                ctx.stroke();
                
                // x축, y축 그리기
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // x축
                const xAxisPos = worldToScreen(canvas, 0, 0);
                ctx.moveTo(graphSettings.margin, xAxisPos.y);
                ctx.lineTo(width - graphSettings.margin, xAxisPos.y);
                
                // y축
                const yAxisPos = worldToScreen(canvas, 0, 0);
                ctx.moveTo(yAxisPos.x, graphSettings.margin);
                ctx.lineTo(yAxisPos.x, height - graphSettings.margin);
                
                ctx.stroke();
                
                // 눈금 및 숫자 표시
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // x축 눈금
                for (let x = Math.ceil(graphSettings.xMin); x <= Math.floor(graphSettings.xMax); x += graphSettings.xAxisStep) {
                    if (x === 0) continue; // 원점은 스킵
                    const pos = worldToScreen(canvas, x, 0);
                    ctx.beginPath();
                    ctx.moveTo(pos.x, xAxisPos.y - 5);
                    ctx.lineTo(pos.x, xAxisPos.y + 5);
                    ctx.stroke();
                    ctx.fillText(x, pos.x, xAxisPos.y + 8);
                }
                
                // y축 눈금
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (let y = Math.ceil(graphSettings.yMin); y <= Math.floor(graphSettings.yMax); y += graphSettings.yAxisStep) {
                    if (y === 0) continue; // 원점은 스킵
                    const pos = worldToScreen(canvas, 0, y);
                    ctx.beginPath();
                    ctx.moveTo(yAxisPos.x - 5, pos.y);
                    ctx.lineTo(yAxisPos.x + 5, pos.y);
                    ctx.stroke();
                    ctx.fillText(y, yAxisPos.x - 8, pos.y);
                }
                
                // 원점 표시
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                ctx.fillText('0', yAxisPos.x - 5, xAxisPos.y + 5);
            }
            
            // 점근선 그리기
            function drawAsymptotes(ctx, canvas) {
                const vAsymptote = worldToScreen(canvas, h, 0);
                const hAsymptote = worldToScreen(canvas, 0, k);
                
                ctx.strokeStyle = graphSettings.asymptoteColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                
                // 수직 점근선
                ctx.beginPath();
                ctx.moveTo(vAsymptote.x, graphSettings.margin);
                ctx.lineTo(vAsymptote.x, canvas.height - graphSettings.margin);
                ctx.stroke();
                
                // 수평 점근선
                ctx.beginPath();
                ctx.moveTo(graphSettings.margin, hAsymptote.y);
                ctx.lineTo(canvas.width - graphSettings.margin, hAsymptote.y);
                ctx.stroke();
                
                // 점근선 텍스트
                ctx.setLineDash([]);
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`x = ${h.toFixed(1)}`, vAsymptote.x + 5, graphSettings.margin);
                ctx.fillText(`y = ${k.toFixed(1)}`, graphSettings.margin, hAsymptote.y - 20);
            }
            
            // 참조점 그리기 (x1, x2)
            function drawReferencePoints(ctx, canvas) {
                // x1 참조선
                const x1Line = worldToScreen(canvas, x1, 0);
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.moveTo(x1Line.x, graphSettings.margin);
                ctx.lineTo(x1Line.x, canvas.height - graphSettings.margin);
                ctx.stroke();
                
                // x2 참조선
                const x2Line = worldToScreen(canvas, x2, 0);
                ctx.strokeStyle = 'purple';
                ctx.beginPath();
                ctx.moveTo(x2Line.x, graphSettings.margin);
                ctx.lineTo(x2Line.x, canvas.height - graphSettings.margin);
                ctx.stroke();
                
                // 참조선 텍스트
                ctx.setLineDash([]);
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillStyle = 'orange';
                ctx.fillText(`x₁ = ${x1.toFixed(1)}`, x1Line.x + 5, graphSettings.margin);
                ctx.fillStyle = 'purple';
                ctx.fillText(`x₂ = ${x2.toFixed(1)}`, x2Line.x + 5, graphSettings.margin);
                
                // 함수값 점 그리기
                const y1 = hyperbolic(x1);
                const y2 = hyperbolic(x2);
                
                const point1 = worldToScreen(canvas, x1, y1);
                const point2 = worldToScreen(canvas, x2, y2);
                
                ctx.setLineDash([]);
                
                // 점 1
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.arc(point1.x, point1.y, graphSettings.pointSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 점 2
                ctx.fillStyle = 'purple';
                ctx.beginPath();
                ctx.arc(point2.x, point2.y, graphSettings.pointSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 쌍곡선 그리기
            function drawHyperbola(ctx, canvas, drawTransformed = false) {
                const step = 0.1;
                
                ctx.strokeStyle = graphSettings.mainCurveColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                
                // 왼쪽 부분 (x < h)
                let isFirst = true;
                ctx.beginPath();
                for (let x = graphSettings.xMin; x < h; x += step) {
                    const y = hyperbolic(x);
                    if (isNaN(y) || Math.abs(y) > 1000) continue;
                    
                    const pos = worldToScreen(canvas, x, y);
                    if (isFirst) {
                        ctx.moveTo(pos.x, pos.y);
                        isFirst = false;
                    } else {
                        ctx.lineTo(pos.x, pos.y);
                    }
                }
                ctx.stroke();
                
                // 오른쪽 부분 (x > h)
                isFirst = true;
                ctx.beginPath();
                for (let x = h + step; x <= graphSettings.xMax; x += step) {
                    const y = hyperbolic(x);
                    if (isNaN(y) || Math.abs(y) > 1000) continue;
                    
                    const pos = worldToScreen(canvas, x, y);
                    if (isFirst) {
                        ctx.moveTo(pos.x, pos.y);
                        isFirst = false;
                    } else {
                        ctx.lineTo(pos.x, pos.y);
                    }
                }
                ctx.stroke();
                
                // 변환된 함수 그리기 (y-k = a/(x-h))
                if (drawTransformed) {
                    ctx.strokeStyle = graphSettings.transformedCurveColor;
                    
                    // 왼쪽 부분 (x < h)
                    isFirst = true;
                    ctx.beginPath();
                    for (let x = graphSettings.xMin; x < h; x += step) {
                        const transformed = a / (x - h);
                        if (isNaN(transformed) || Math.abs(transformed) > 1000) continue;
                        
                        const pos = worldToScreen(canvas, x, transformed);
                        if (isFirst) {
                            ctx.moveTo(pos.x, pos.y);
                            isFirst = false;
                        } else {
                            ctx.lineTo(pos.x, pos.y);
                        }
                    }
                    ctx.stroke();
                    
                    // 오른쪽 부분 (x > h)
                    isFirst = true;
                    ctx.beginPath();
                    for (let x = h + step; x <= graphSettings.xMax; x += step) {
                        const transformed = a / (x - h);
                        if (isNaN(transformed) || Math.abs(transformed) > 1000) continue;
                        
                        const pos = worldToScreen(canvas, x, transformed);
                        if (isFirst) {
                            ctx.moveTo(pos.x, pos.y);
                            isFirst = false;
                        } else {
                            ctx.lineTo(pos.x, pos.y);
                        }
                    }
                    ctx.stroke();
                }
                
                // 함수 설명 텍스트
                ctx.font = '14px Arial';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`f(x) = ${a}/(x-${h.toFixed(1)}) + ${k.toFixed(1)}`, graphSettings.margin, graphSettings.margin);
                
                if (drawTransformed) {
                    ctx.fillStyle = graphSettings.transformedCurveColor;
                    ctx.fillText(`y-${k.toFixed(1)} = ${a}/(x-${h.toFixed(1)})`, graphSettings.margin, graphSettings.margin + 20);
                }
            }
            
            // 그래프 1 그리기 (기본 쌍곡선)
            function drawGraph1() {
                ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
                drawAxes(ctx1, canvas1);
                drawAsymptotes(ctx1, canvas1);
                drawHyperbola(ctx1, canvas1);
            }
            
            // 그래프 2 그리기 (변환된 쌍곡선)
            function drawGraph2() {
                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
                drawAxes(ctx2, canvas2);
                drawAsymptotes(ctx2, canvas2);
                drawHyperbola(ctx2, canvas2, true);
            }
            
            // 그래프 3 그리기 (평균변화율)
            function drawGraph3() {
                ctx3.clearRect(0, 0, canvas3.width, canvas3.height);
                drawAxes(ctx3, canvas3);
                drawAsymptotes(ctx3, canvas3);
                drawReferencePoints(ctx3, canvas3);
                drawHyperbola(ctx3, canvas3);
            }
            
            // 모든 그래프 업데이트
            function updateGraphs() {
                drawGraph1();
                drawGraph2();
                drawGraph3();
                updateDisplayValues();
            }
            
            // 평균변화율 계산
            function calculateAverageRate() {
                const f1 = a / (x1 - h) + k;
                const f2 = a / (x2 - h) + k;
                return (f2 - f1) / (x2 - x1);
            }
            
            // 미분 계산
            function calculateRateDerivative() {
                return -a / Math.pow(x2 - h, 2);
            }
            
            // 비례식 결과 계산
            function calculateProportionalExpression() {
                const derivative = calculateRateDerivative();
                const X1 = x1 - h;
                const X2 = x2 - h;
                return Math.abs(derivative * X1 * X2 * X2);
            }
            
            // 디스플레이 값 업데이트
            function updateDisplayValues() {
                // 슬라이더 값 업데이트
                aValue.textContent = a.toFixed(1);
                hValue.textContent = h.toFixed(1);
                kValue.textContent = k.toFixed(1);
                x1Value.textContent = x1.toFixed(1);
                x2Value.textContent = x2.toFixed(1);
                
                // 그래프 1 디스플레이 값
                document.getElementById('h-display').textContent = h.toFixed(1);
                document.getElementById('k-display').textContent = k.toFixed(1);
                document.getElementById('k-limit-neg').textContent = k.toFixed(1);
                document.getElementById('k-limit-pos').textContent = k.toFixed(1);
                
                // 그래프 2 디스플레이 값
                document.getElementById('h-display2').textContent = h.toFixed(1);
                document.getElementById('k-display2').textContent = k.toFixed(1);
                document.getElementById('a-display2').textContent = a.toFixed(1);
                document.getElementById('h-display3').textContent = h.toFixed(1);
                document.getElementById('k-display3').textContent = k.toFixed(1);
                document.getElementById('a-display3').textContent = a.toFixed(1);
                document.getElementById('h-display4').textContent = h.toFixed(1);
                document.getElementById('k-display4').textContent = k.toFixed(1);
                document.getElementById('a-display4').textContent = a.toFixed(1);
                
                // 그래프 3 디스플레이 값
                const f1 = a / (x1 - h) + k;
                const f2 = a / (x2 - h) + k;
                document.getElementById('x1-display').textContent = x1.toFixed(1);
                document.getElementById('y1-display').textContent = f1.toFixed(2);
                document.getElementById('x2-display').textContent = x2.toFixed(1);
                document.getElementById('y2-display').textContent = f2.toFixed(2);
                
                const avgRate = calculateAverageRate();
                const derivative = calculateRateDerivative();
                const proportionalResult = calculateProportionalExpression();
                
                document.getElementById('avg-rate').textContent = avgRate.toFixed(4);
                document.getElementById('derivative').textContent = derivative.toFixed(4);
                document.getElementById('proportional-result').textContent = proportionalResult.toFixed(4);
                document.getElementById('a-display5').textContent = a.toFixed(1);
                
                // x1, x2 슬라이더 범위 업데이트
                x1Slider.min = (h + 0.5).toFixed(1);
                x2Slider.min = (parseFloat(x1) + 0.5).toFixed(1);
            }
            
            // 마우스/터치 이벤트 처리
            function handleMouseDown(e, canvas) {
                e.preventDefault();
                isDragging = true;
                activeCanvas = canvas;
                updateFromDrag(e);
            }
            
            function handleMouseMove(e) {
                if (!isDragging) return;
                updateFromDrag(e);
            }
            
            function handleMouseUp() {
                isDragging = false;
                activeCanvas = null;
            }
            
            function getMousePos(e) {
                const canvas = activeCanvas;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                return { x, y };
            }
            
            function updateFromDrag(e) {
                if (!activeCanvas) return;
                
                const mousePos = getMousePos(e);
                const worldPos = screenToWorld(activeCanvas, mousePos.x, mousePos.y);
                
                // Canvas 1: 모든 매개변수 업데이트
                if (activeCanvas === canvas1) {
                    // k는 직접 업데이트
                    k = Math.min(Math.max(worldPos.y, -5), 5);
                    
                    // h는 제한 범위 내에서 업데이트
                    if (Math.abs(worldPos.x - h) > 0.5) {
                        h = Math.min(Math.max(worldPos.x, -5), 5);
                    }
                    
                    // a는 마우스 위치에 따라 계산
                    const centerX = activeCanvas.width / 2;
                    const centerY = activeCanvas.height / 2;
                    const distance = Math.sqrt(Math.pow(mousePos.x - centerX, 2) + Math.pow(mousePos.y - centerY, 2));
                    const maxDistance = Math.sqrt(Math.pow(activeCanvas.width, 2) + Math.pow(activeCanvas.height, 2)) / 2;
                    a = 0.5 + 4.5 * (distance / maxDistance);
                    a = Math.min(Math.max(a, 0.5), 5);
                }
                // Canvas 2: h와 k만 업데이트
                else if (activeCanvas === canvas2) {
                    // k는 직접 업데이트
                    k = Math.min(Math.max(worldPos.y, -5), 5);
                    
                    // h는 제한 범위 내에서 업데이트
                    if (Math.abs(worldPos.x - h) > 0.5) {
                        h = Math.min(Math.max(worldPos.x, -5), 5);
                    }
                }
                // Canvas 3: x1과 x2 업데이트
                else if (activeCanvas === canvas3) {
                    const minX = h + 0.5;
                    const newX1 = Math.min(Math.max(worldPos.x, minX), 10);
                    
                    // x1이 올바른 범위에 있는지 확인
                    if (newX1 > h + 0.1) {
                        // 먼저 x1을 업데이트하고,
                        if (worldPos.x < x2 - 0.5) {
                            x1 = newX1;
                        }
                        // 그 다음 x2를 업데이트
                        else if (worldPos.x > x1 + 0.5) {
                            x2 = Math.min(Math.max(worldPos.x, x1 + 0.5), 12);
                        }
                    }
                }
                
                // 슬라이더 값 업데이트
                aSlider.value = a;
                hSlider.value = h;
                kSlider.value = k;
                x1Slider.value = x1;
                x2Slider.value = x2;
                
                // 그래프와 표시 값 업데이트
                updateGraphs();
            }
            
            // 슬라이더 이벤트 리스너
            aSlider.addEventListener('input', function() {
                a = parseFloat(this.value);
                updateGraphs();
            });
            
            hSlider.addEventListener('input', function() {
                h = parseFloat(this.value);
                updateGraphs();
            });
            
            kSlider.addEventListener('input', function() {
                k = parseFloat(this.value);
                updateGraphs();
            });
            
            x1Slider.addEventListener('input', function() {
                x1 = parseFloat(this.value);
                // x2를 x1보다 크게 유지
                if (x2 <= x1 + 0.5) {
                    x2 = x1 + 0.5;
                    x2Slider.value = x2;
                }
                updateGraphs();
            });
            
            x2Slider.addEventListener('input', function() {
                x2 = parseFloat(this.value);
                updateGraphs();
            });
            
            // 캔버스 이벤트 리스너
            canvas1.addEventListener('mousedown', e => handleMouseDown(e, canvas1));
            canvas2.addEventListener('mousedown', e => handleMouseDown(e, canvas2));
            canvas3.addEventListener('mousedown', e => handleMouseDown(e, canvas3));
            
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            
            // 터치 이벤트 처리 (모바일 지원)
            canvas1.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMouseDown(mouseEvent, canvas1);
            });
            
            canvas2.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMouseDown(mouseEvent, canvas2);
            });
            
            canvas3.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMouseDown(mouseEvent, canvas3);
            });
            
            window.addEventListener('touchmove', e => {
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMouseMove(mouseEvent);
            });
            
            window.addEventListener('touchend', handleMouseUp);
            
            // 초기 그래프 그리기
            updateGraphs();
        });
    </script>
</body>
</html>