<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>나비에-스토크스 방정식 시뮬레이션</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    
    .title {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1.5rem;
      text-align: center;
    }
    
    .equation-box {
      margin-bottom: 1rem;
      padding: 1rem;
      background-color: #f0f0f0;
      border-radius: 0.5rem;
      width: 100%;
    }
    
    .equation-title {
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
      margin-bottom: 0.5rem;
    }
    
    .equation {
      font-size: 1.2rem;
      text-align: center;
      margin: 0.5rem 0;
    }
    
    .equation-desc {
      font-size: 0.875rem;
      text-align: center;
      margin-top: 0.25rem;
    }
    
    .relation {
      font-size: 1rem;
      font-weight: 600;
      text-align: center;
      margin-top: 0.75rem;
    }
    
    .values-display {
      display: flex;
      justify-content: space-between;
      margin-top: 1rem;
    }
    
    .value-box {
      padding: 0.5rem;
      border-radius: 0.375rem;
    }
    
    .value-box.inertia {
      background-color: #dbeafe;
    }
    
    .value-box.pressure {
      background-color: #d1fae5;
    }
    
    .value-title {
      font-weight: 600;
    }
    
    .value {
      font-size: 1.2rem;
    }
    
    .log-value {
      font-size: 0.875rem;
    }
    
    .controls {
      margin-bottom: 1rem;
      padding: 1rem;
      background-color: #f0f0f0;
      border-radius: 0.5rem;
      width: 100%;
    }
    
    .slider-container {
      margin-bottom: 0.75rem;
    }
    
    .slider-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    .slider {
      width: 100%;
      height: 0.5rem;
      border-radius: 9999px;
      appearance: none;
      cursor: pointer;
    }
    
    .slider.x-slider {
      background-color: #dbeafe;
    }
    
    .slider.y-slider {
      background-color: #d1fae5;
    }
    
    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
    }
    
    .slider-range {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    
    .buttons-container {
      margin-bottom: 0.5rem;
    }
    
    .buttons-group {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .button-label {
      margin-right: 1rem;
    }
    
    .button {
      padding: 0.25rem 1rem;
      margin-right: 0.5rem;
      border-radius: 0.25rem;
      background-color: #e5e7eb;
      border: none;
      cursor: pointer;
    }
    
    .button.active.x-button {
      background-color: #3b82f6;
      color: white;
    }
    
    .button.active.y-button {
      background-color: #10b981;
      color: white;
    }
    
    .button.active.scale-button {
      background-color: #8b5cf6;
      color: white;
    }
    
    .button.active.prediction-button {
      background-color: #f59e0b;
      color: white;
    }
    
    .svg-container {
      overflow: auto;
      margin-bottom: 1rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
    }
    
    .quadrant-info {
      margin-top: 1.5rem;
      padding: 1rem;
      background-color: #f0f0f0;
      border-radius: 0.5rem;
      width: 100%;
    }
    
    .quadrant-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .quadrant-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }
    
    .quadrant {
      padding: 0.5rem;
      border-radius: 0.375rem;
    }
    
    .quadrant-1, .quadrant-2 {
      background-color: #dbeafe;
    }
    
    .quadrant-3, .quadrant-4 {
      background-color: #fee2e2;
    }
    
    .quadrant-name {
      font-weight: 600;
    }
    
    .quadrant-desc {
      font-size: 0.875rem;
    }
    
    .prediction-info {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #fef3c7;
      border-radius: 0.5rem;
      width: 100%;
    }
    
    .prediction-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .usage-guide {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #dbeafe;
      border-radius: 0.5rem;
      width: 100%;
    }
    
    .guide-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .guide-list {
      list-style-type: disc;
      padding-left: 1.25rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="title">나비에-스토크스 방정식의 관계 시각화</div>
    
    <div class="equation-box">
      <div class="equation-title">나비에-스토크스 방정식</div>
      <div class="equation">ρ(∂u/∂t + u·∇u) = -∇p + μ∇²u + F</div>
      <div class="equation-desc">좌항: 관성항 | 우항: 압력항 및 점성항</div>
      <div class="relation">관계식: y = ±k/x (k = 20)</div>
      <div class="equation-desc">양수/음수 영역 모두 포함, 점선은 극한 영역 예측값</div>
      
      <div class="values-display">
        <div class="value-box inertia">
          <div class="value-title">관성항 (좌항)</div>
          <div class="value" id="x-value">5.00</div>
          <div class="log-value" id="x-log-value" style="display: none;">로그: 0.70 (부호: +)</div>
        </div>
        <div class="value-box pressure">
          <div class="value-title">압력 및 점성항 (우항)</div>
          <div class="value" id="y-value">4.00</div>
          <div class="log-value" id="y-log-value" style="display: none;">로그: 0.60 (부호: +)</div>
        </div>
      </div>
    </div>
    
    <div class="controls">
      <div class="slider-container">
        <label class="slider-label" for="x-slider">관성항 값 (X) 조절: <span id="x-slider-value">5.00</span></label>
        <input type="range" id="x-slider" class="slider x-slider" min="-20" max="20" step="0.1" value="5">
        <div class="slider-range">
          <span>-20</span>
          <span>0</span>
          <span>20</span>
        </div>
      </div>
      
      <div class="slider-container">
        <label class="slider-label" for="y-slider">압력 및 점성항 값 (Y) 조절: <span id="y-slider-value">4.00</span></label>
        <input type="range" id="y-slider" class="slider y-slider" min="-50" max="50" step="0.1" value="4">
        <div class="slider-range">
          <span>-50</span>
          <span>0</span>
          <span>50</span>
        </div>
      </div>
    </div>
    
    <div class="buttons-container">
      <div class="buttons-group">
        <span class="button-label">드래그 모드:</span>
        <button class="button x-button active" id="x-drag-button">좌항 기준 (X축)</button>
        <button class="button y-button" id="y-drag-button">우항 기준 (Y축)</button>
      </div>
      
      <div class="buttons-group">
        <span class="button-label">스케일:</span>
        <button class="button scale-button active" id="normal-scale-button">일반 스케일</button>
        <button class="button scale-button" id="log-scale-button">로그 스케일</button>
      </div>
      
      <div class="buttons-group">
        <span class="button-label">예측선:</span>
        <button class="button prediction-button active" id="show-prediction-button">표시</button>
        <button class="button prediction-button" id="hide-prediction-button">숨기기</button>
      </div>
    </div>
    
    <div class="svg-container" id="svg-container"></div>
    
    <div class="quadrant-info">
      <div class="quadrant-title">사분면 해석:</div>
      <div class="quadrant-grid">
        <div class="quadrant quadrant-1">
          <div class="quadrant-name">1사분면 (파란선, 상단 오른쪽)</div>
          <div class="quadrant-desc">정방향: 양의 관성항 → 양의 압력/점성항</div>
          <div class="quadrant-desc">일반적인 유체 흐름</div>
        </div>
        <div class="quadrant quadrant-2">
          <div class="quadrant-name">2사분면 (파란선, 상단 왼쪽)</div>
          <div class="quadrant-desc">음의 관성항 → 양의 압력/점성항</div>
          <div class="quadrant-desc">역방향 가속</div>
        </div>
        <div class="quadrant quadrant-3">
          <div class="quadrant-name">3사분면 (빨간선, 하단 왼쪽)</div>
          <div class="quadrant-desc">음의 관성항 → 음의 압력/점성항</div>
          <div class="quadrant-desc">반대방향 흐름</div>
        </div>
        <div class="quadrant quadrant-4">
          <div class="quadrant-name">4사분면 (빨간선, 하단 오른쪽)</div>
          <div class="quadrant-desc">양의 관성항 → 음의 압력/점성항</div>
          <div class="quadrant-desc">음의 압력(흡인력) 영역</div>
        </div>
      </div>
    </div>
    
    <div class="prediction-info">
      <div class="prediction-title">극한 예측 해석:</div>
      <div>
        점선으로 표시된 영역은 극한 예측값을 나타냅니다. x→0 또는 x→±∞로 접근할 때의 방정식 동작을 
        예측합니다. x가 0에 가까워질수록 y값은 무한대로 발산하며, x가 무한대로 커질수록 y값은 0에 수렴합니다.
        이는 나비에-스토크스 방정식에서 관성항이 매우 작을 때 압력/점성항이 지배적이 되고,
        관성항이 매우 클 때는 압력/점성항의 영향이 상대적으로 작아짐을 의미합니다.
      </div>
    </div>
    
    <div class="usage-guide">
      <div class="guide-title">사용 가이드:</div>
      <ul class="guide-list">
        <li>그래프 영역을 <b>클릭하거나 드래그</b>하여 점 위치를 이동할 수 있습니다.</li>
        <li>위쪽 <b>슬라이더</b>를 사용하여 X값과 Y값을 직접 조절할 수 있습니다.</li>
        <li><b>드래그 모드</b>를 변경하여 X축 또는 Y축을 기준으로 이동할 수 있습니다.</li>
        <li><b>스케일</b> 버튼으로 일반/로그 스케일을 전환할 수 있습니다.</li>
      </ul>
    </div>
  </div>

  <script>
    // 상태 변수
    let mode = 'normal'; // 'normal' or 'log'
    let xValue = 5;
    let yValue = 4;
    let dragMode = 'x'; // 'x' or 'y'
    let showPredictions = true; // 예측선 표시 여부
    
    // 상수
    const K = 20; // 반비례 상수
    
    // DOM 요소 참조
    const svgContainer = document.getElementById('svg-container');
    
    // 함수: 관성항과 나머지 항의 관계 계산
    function calculateY(x) {
      return K / x;
    }
    
    function calculateX(y) {
      return K / y;
    }
    
    // 함수: x 값이 변경될 때 y 값 업데이트
    function updateYFromX(x) {
      // 0에 너무 가깝지 않도록
      if (Math.abs(x) < 0.1) {
        x = x >= 0 ? 0.1 : -0.1;
      }
      
      // 사분면에 따라 y 값 계산
      let newY;
      if (x > 0) {
        newY = yValue > 0 ? calculateY(x) : -calculateY(x);
      } else {
        newY = yValue > 0 ? calculateY(x) : -calculateY(-x);
      }
      
      xValue = x;
      yValue = newY;
      updateSliders();
      updateValueDisplay();
      drawGraph();
    }
    
    // 함수: y 값이 변경될 때 x 값 업데이트
    function updateXFromY(y) {
      // 0에 너무 가깝지 않도록
      if (Math.abs(y) < 0.1) {
        y = y >= 0 ? 0.1 : -0.1;
      }
      
      let newX;
      if (y > 0) {
        newX = xValue > 0 ? calculateX(y) : -calculateX(y);
      } else {
        newX = xValue > 0 ? calculateX(-y) : -calculateX(-y);
      }
      
      yValue = y;
      xValue = newX;
      updateSliders();
      updateValueDisplay();
      drawGraph();
    }
    
    // 함수: 슬라이더 범위 업데이트
    function updateSliderRanges() {
      const xSlider = document.getElementById('x-slider');
      const ySlider = document.getElementById('y-slider');
      const xSliderRange = xSlider.parentElement.querySelector('.slider-range');
      const ySliderRange = ySlider.parentElement.querySelector('.slider-range');
      
      if (mode === 'log') {
        xSlider.min = -100;
        xSlider.max = 100;
        ySlider.min = -100;
        ySlider.max = 100;
        xSliderRange.innerHTML = '<span>-100</span><span>0</span><span>100</span>';
        ySliderRange.innerHTML = '<span>-100</span><span>0</span><span>100</span>';
      } else {
        xSlider.min = -20;
        xSlider.max = 20;
        ySlider.min = -50;
        ySlider.max = 50;
        xSliderRange.innerHTML = '<span>-20</span><span>0</span><span>20</span>';
        ySliderRange.innerHTML = '<span>-50</span><span>0</span><span>50</span>';
      }
    }
    
    // 함수: 슬라이더 값 업데이트
    function updateSliders() {
      const xSlider = document.getElementById('x-slider');
      const ySlider = document.getElementById('y-slider');
      
      // 슬라이더 범위 내로 값 제한
      let displayX = xValue;
      let displayY = yValue;
      
      if (mode === 'log') {
        displayX = Math.max(-100, Math.min(100, displayX));
        displayY = Math.max(-100, Math.min(100, displayY));
      } else {
        displayX = Math.max(-20, Math.min(20, displayX));
        displayY = Math.max(-50, Math.min(50, displayY));
      }
      
      xSlider.value = displayX;
      ySlider.value = displayY;
      
      // 슬라이더 레이블 값도 업데이트
      document.getElementById('x-slider-value').textContent = displayX.toFixed(2);
      document.getElementById('y-slider-value').textContent = displayY.toFixed(2);
    }
    
    // 함수: 값 표시 업데이트
    function updateValueDisplay() {
      document.getElementById('x-value').textContent = xValue.toFixed(2);
      document.getElementById('y-value').textContent = yValue.toFixed(2);
      
      // 로그 값 계산 및 표시 (로그 모드일 때만)
      if (mode === 'log') {
        document.getElementById('x-log-value').textContent = 
          `로그: ${Math.log10(Math.abs(xValue)).toFixed(2)} (부호: ${xValue < 0 ? '-' : '+'})`;
        document.getElementById('y-log-value').textContent = 
          `로그: ${Math.log10(Math.abs(yValue)).toFixed(2)} (부호: ${yValue < 0 ? '-' : '+'})`;
        
        document.getElementById('x-log-value').style.display = 'block';
        document.getElementById('y-log-value').style.display = 'block';
      } else {
        document.getElementById('x-log-value').style.display = 'none';
        document.getElementById('y-log-value').style.display = 'none';
      }
    }
    
    // 함수: 그래프 그리기
    function drawGraph() {
      // 기존 SVG 요소 제거
      svgContainer.innerHTML = '';
      
      // SVG 요소 생성
      const svgWidth = 600;
      const svgHeight = 400;
      const margin = { top: 40, right: 60, bottom: 60, left: 60 };
      const width = svgWidth - margin.left - margin.right;
      const height = svgHeight - margin.top - margin.bottom;
      
      const svg = d3.select('#svg-container')
        .append('svg')
        .attr('width', svgWidth)
        .attr('height', svgHeight)
        .append('g')
        .attr('transform', `translate(${margin.left}, ${margin.top})`);
      
      // 스케일 정의
      let xScale, yScale;
      
      if (mode === 'log') {
        // 로그 스케일 정의
        xScale = d3.scaleSymlog()
          .domain([-100, 100])
          .range([0, width])
          .constant(1);
        
        yScale = d3.scaleSymlog()
          .domain([-100, 100])
          .range([height, 0])
          .constant(1);
      } else {
        // 일반 선형 스케일 정의
        xScale = d3.scaleLinear()
          .domain([-20, 20])
          .range([0, width]);
        
        yScale = d3.scaleLinear()
          .domain([-50, 50])
          .range([height, 0]);
      }
      
      // 축 생성
      const xAxis = d3.axisBottom(xScale);
      const yAxis = d3.axisLeft(yScale);
      
      svg.append('g')
        .attr('transform', `translate(0, ${height/2})`) // x축을 중앙에 위치
        .attr('class', 'x-axis')
        .call(xAxis);
      
      svg.append('g')
        .attr('transform', `translate(${width/2}, 0)`) // y축을 중앙에 위치
        .attr('class', 'y-axis')
        .call(yAxis);
      
      // 축 레이블
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', height + 30)
        .style('text-anchor', 'middle')
        .text(`관성항 (좌항) ${mode === 'log' ? '- 로그 스케일' : ''}`);
      
      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -40)
        .style('text-anchor', 'middle')
        .text(`압력 및 점성항 (우항) ${mode === 'log' ? '- 로그 스케일' : ''}`);
      
      // 그래프 제목
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', -20)
        .style('text-anchor', 'middle')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text(`나비에-스토크스 방정식의 ${mode === 'log' ? '로그 스케일' : '쌍곡선'} 관계`);
      
      // 격자 그리기
      svg.append('line')
        .attr('x1', 0)
        .attr('y1', height/2)
        .attr('x2', width)
        .attr('y2', height/2)
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1);
      
      svg.append('line')
        .attr('x1', width/2)
        .attr('y1', 0)
        .attr('x2', width/2)
        .attr('y2', height)
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1);
      
      // 네 개의 영역에 대한 곡선 생성
      // 1사분면: x > 0, y > 0
      const curve1 = [];
      for (let x = 0.1; x <= 20; x += 0.1) {
        curve1.push({ x: x, y: calculateY(x) });
      }
      
      // 2사분면: x < 0, y > 0
      const curve2 = [];
      for (let x = -20; x < -0.1; x += 0.1) {
        curve2.push({ x: x, y: calculateY(x) });
      }
      
      // 3사분면: x < 0, y < 0
      const curve3 = [];
      for (let x = -20; x < -0.1; x += 0.1) {
        curve3.push({ x: x, y: -calculateY(-x) });
      }
      
      // 4사분면: x > 0, y < 0
      const curve4 = [];
      for (let x = 0.1; x <= 20; x += 0.1) {
        curve4.push({ x: x, y: -calculateY(x) });
      }
      
      // 확장 예측 곡선 (더 극단적인 영역)
      const predictionCurve1 = [];
      const predictionCurve2 = [];
      const predictionCurve3 = [];
      const predictionCurve4 = [];
      
      if (showPredictions) {
        // 더 작은 x 값 (극한에 가까워짐)
        for (let x = 0.01; x < 0.1; x += 0.005) {
          predictionCurve1.push({ x: x, y: calculateY(x) });
          predictionCurve4.push({ x: x, y: -calculateY(x) });
        }
        
        for (let x = -0.1; x > -0.01; x -= 0.005) {
          predictionCurve2.push({ x: x, y: calculateY(x) });
          predictionCurve3.push({ x: x, y: -calculateY(-x) });
        }
        
        // 더 큰 x 값 (무한대로 접근)
        for (let x = 20; x <= 100; x += 2) {
          predictionCurve1.push({ x: x, y: calculateY(x) });
          predictionCurve4.push({ x: x, y: -calculateY(x) });
        }
        
        for (let x = -100; x <= -20; x += 2) {
          predictionCurve2.push({ x: x, y: calculateY(x) });
          predictionCurve3.push({ x: x, y: -calculateY(-x) });
        }
      }
      
      // 선 생성기
      const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y))
        .curve(d3.curveMonotoneX);
      
      // 곡선 그리기 (주 곡선)
      // 1사분면
      svg.append('path')
        .datum(curve1)
        .attr('fill', 'none')
        .attr('stroke', 'steelblue')
        .attr('stroke-width', 2)
        .attr('d', line);
      
      // 2사분면
      svg.append('path')
        .datum(curve2)
        .attr('fill', 'none')
        .attr('stroke', 'steelblue')
        .attr('stroke-width', 2)
        .attr('d', line);
      
      // 3사분면
      svg.append('path')
        .datum(curve3)
        .attr('fill', 'none')
        .attr('stroke', 'tomato')
        .attr('stroke-width', 2)
        .attr('d', line);
      
      // 4사분면
      svg.append('path')
        .datum(curve4)
        .attr('fill', 'none')
        .attr('stroke', 'tomato')
        .attr('stroke-width', 2)
        .attr('d', line);
      
      // 예측 곡선 그리기 (점선으로 표시)
      if (showPredictions) {
        // 1사분면 예측
        svg.append('path')
          .datum(predictionCurve1)
          .attr('fill', 'none')
          .attr('stroke', 'steelblue')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '5,5')
          .attr('d', line);
        
        // 2사분면 예측
        svg.append('path')
          .datum(predictionCurve2)
          .attr('fill', 'none')
          .attr('stroke', 'steelblue')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '5,5')
          .attr('d', line);
        
        // 3사분면 예측
        svg.append('path')
          .datum(predictionCurve3)
          .attr('fill', 'none')
          .attr('stroke', 'tomato')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '5,5')
          .attr('d', line);
        
        // 4사분면 예측
        svg.append('path')
          .datum(predictionCurve4)
          .attr('fill', 'none')
          .attr('stroke', 'tomato')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '5,5')
          .attr('d', line);
      }
      
      // 분면 레이블 추가
      svg.append('text')
        .attr('x', 3 * width / 4)
        .attr('y', height / 4)
        .style('text-anchor', 'middle')
        .text('정방향')
        .style('font-size', '12px');
      
      svg.append('text')
        .attr('x', width / 4)
        .attr('y', height / 4)
        .style('text-anchor', 'middle')
        .text('음의 관성항')
        .style('font-size', '12px');
      
      svg.append('text')
        .attr('x', width / 4)
        .attr('y', 3 * height / 4)
        .style('text-anchor', 'middle')
        .text('반대방향')
        .style('font-size', '12px');
      
      svg.append('text')
        .attr('x', 3 * width / 4)
        .attr('y', 3 * height / 4)
        .style('text-anchor', 'middle')
        .text('음의 압력항')
        .style('font-size', '12px');
      
      // 현재 점 위치 조정
      let displayX = xValue;
      let displayY = yValue;
      
      // 점이 유효 범위 내에 있는지 확인
      if (mode === 'log') {
        displayX = Math.max(-100, Math.min(100, displayX));
        displayY = Math.max(-100, Math.min(100, displayY));
      } else {
        displayX = Math.max(-20, Math.min(20, displayX));
        displayY = Math.max(-50, Math.min(50, displayY));
      }
      
      // 현재 점 그리기 - 크기를 키워서 클릭하기 쉽게 함
      // 주의를 끌기 위한 외부 원
      svg.append('circle')
        .attr('cx', xScale(displayX))
        .attr('cy', yScale(displayY))
        .attr('r', 12)
        .attr('fill', 'rgba(255, 0, 0, 0.2)')
        .attr('stroke', 'red')
        .attr('stroke-width', 2);
      
      // 내부 점
      const currentPoint = svg.append('circle')
        .attr('cx', xScale(displayX))
        .attr('cy', yScale(displayY))
        .attr('r', 8)
        .attr('fill', 'red');
      
      // 드래그 기능
      function dragStarted(event) {
        d3.select(this).attr('stroke', 'black');
      }
      
      function dragged(event) {
        if (dragMode === 'x') {
          // X축 방향으로만 드래그
          const newX = xScale.invert(event.x);
          
          // 유효 범위로 제한
          let adjustedX;
          if (mode === 'log') {
            adjustedX = Math.max(-100, Math.min(100, newX));
          } else {
            adjustedX = Math.max(-20, Math.min(20, newX));
          }
          
          updateYFromX(adjustedX);
        } else {
          // Y축 방향으로만 드래그
          const newY = yScale.invert(event.y);
          
          // 유효 범위로 제한
          let adjustedY;
          if (mode === 'log') {
            adjustedY = Math.max(-100, Math.min(100, newY));
          } else {
            adjustedY = Math.max(-50, Math.min(50, newY));
          }
          
          updateXFromY(adjustedY);
        }
        
        // 점 위치 업데이트
        currentPoint
          .attr('cx', xScale(xValue))
          .attr('cy', yScale(yValue));
      }
      
      function dragEnded(event) {
        d3.select(this).attr('stroke', null);
      }
      
      const drag = d3.drag()
        .on('start', dragStarted)
        .on('drag', dragged)
        .on('end', dragEnded);
      
      // 전체 그래프 영역에 이벤트 추가
      svg.append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'transparent')
        .call(drag);
      
      // 점에도 드래그 이벤트 추가
      currentPoint.call(drag);
    }
    
    // 이벤트 리스너 설정
    document.getElementById('x-slider').addEventListener('input', function() {
      updateYFromX(parseFloat(this.value));
    });
    
    document.getElementById('y-slider').addEventListener('input', function() {
      updateXFromY(parseFloat(this.value));
    });
    
    document.getElementById('x-drag-button').addEventListener('click', function() {
      dragMode = 'x';
      this.classList.add('active');
      document.getElementById('y-drag-button').classList.remove('active');
    });
    
    document.getElementById('y-drag-button').addEventListener('click', function() {
      dragMode = 'y';
      this.classList.add('active');
      document.getElementById('x-drag-button').classList.remove('active');
    });
    
    document.getElementById('normal-scale-button').addEventListener('click', function() {
      mode = 'normal';
      this.classList.add('active');
      document.getElementById('log-scale-button').classList.remove('active');
      updateSliderRanges();
      updateSliders();
      updateValueDisplay();
      drawGraph();
    });
    
    document.getElementById('log-scale-button').addEventListener('click', function() {
      mode = 'log';
      this.classList.add('active');
      document.getElementById('normal-scale-button').classList.remove('active');
      updateSliderRanges();
      updateSliders();
      updateValueDisplay();
      drawGraph();
    });
    
    document.getElementById('show-prediction-button').addEventListener('click', function() {
      showPredictions = true;
      this.classList.add('active');
      document.getElementById('hide-prediction-button').classList.remove('active');
      drawGraph();
    });
    
    document.getElementById('hide-prediction-button').addEventListener('click', function() {
      showPredictions = false;
      this.classList.add('active');
      document.getElementById('show-prediction-button').classList.remove('active');
      drawGraph();
    });
    
    // 초기화
    updateSliders();
    updateValueDisplay();
    drawGraph();
  </script>
</body>
</html>